[TOC]

# 牛客IOS面经整理

**要点：**

计网：TCP/UDP/IP、HTTP、DNS、web页面请求过程

OS：进程、线程、锁

数据结构：几种排序算法、B/B+树

C++/JAVA语言基础：hashmap原理

IOS相关/其他：MVC/MVVM、GET和POST、Socket通信原理、JSON数据传输、有web开发经验的优先

## 计网

### 1. TCP/UDP

#### TCP四层模型，每层常见协议

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/>

![img](https://img-blog.csdnimg.cn/20190802001835308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbnNreTU4Njg1,size_16,color_FFFFFF,t_70)

#### ARP协议，ARP在网络层

每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 **IP 地址到 MAC 地址的映射表**。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过**广播**的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

#### TCP和UDP

   - 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
   - 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

   - **UDP 首部格式**

   首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"/> </div><br>

   - **TCP 首部格式**

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"/> </div><br>

#### TCP 的三次握手

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"/> </div><br>

A 为客户端，B 为服务器端。checksum、ack、seq：sequence number

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

- B 收到 A 的确认后，连接建立。

**三次握手的原因：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。**

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

**如何用UDP设计一个可靠连接？**

#### TCP 的四次挥手

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。

- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

- 当 B 不再需要连接时，发送连接释放报文，FIN=1。

- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

- B 收到 A 的确认后释放连接。

**四次挥手的原因**  ：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。**这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。**

**TIME_WAIT**  ：客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

#### TCP滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果**发送窗口左部的字节已经发送并且收到了确认**，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，**接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口**。

**接收窗口只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"/> </div><br>

#### TCP流量控制

流量控制是为了控制发送方**发送速率**，保证接收方来得及接收。**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小**，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

#### TCP拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。**流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"/> </div><br>

TCP 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复**。

发送方需要维护一个叫做**拥塞窗口（cwnd）**的状态变量，注意拥塞窗口与发送方窗口的区别：**拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口**。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>

1. **慢开始与拥塞避免**

   发送的最初执行慢开始，令 **cwnd = 1**，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

   注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，**当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1**。

   如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

2. **快重传与快恢复**

   在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

   在发送方，**如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传**，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

   在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行**快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh**（如⑤）。

   **慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。**

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"/> </div><br>

### 2. HTTP、HTTPS

1. [HTTP常见状态码](https://blog.csdn.net/laishaohe/article/details/79052085)

   200 – 请求成功

   301 – 资源(网页等)被永久转移到其它URL

   404 – 请求的资源(网页等)不存在

   500 – 内部服务器错误

2. HTTP和HTTPS的区别，HTTPS加密过程（https是如何安全的，用到了什么加密算法，怎么获取私钥），中间URL怎么变，HTTP的长连接和短连接，HTTP头部有哪些内容，http2.0和http1.0区别,如果没有http2.0，怎么解决短连接问题

#### HTTP

超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种**发布和接收 HTML 页面的方法**。HTTP 协议是以**明文**方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

① 客户端的浏览器首先要通过 TCP 与服务器建立连接，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

#### HTTPS设计目标

HTTPS 的安全基础是 **SSL**。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，SSL 协议可分为两层：**SSL 记录协议（SSL Record Protocol）**，它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。**SSL 握手协议（SSL Handshake Protocol）**，它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。**在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手，这样可以防重放攻击。**

<img src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

1. **数据保密性**：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。

2. **数据完整性**：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

3. **身份校验安全性**：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。

#### HTTP 与 HTTPS的区别，HTTPS相对于HTTP的改进

1. HTTPS 协议需要到 **CA （Certificate Authority，证书颁发机构）申请证书**，一般免费证书较少，因而需要一定费用。

2. HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 **SSL 加密传输协议**。

3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是**80**，后者是**443**。

4. HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

#### 关于CA

- 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。**这套证书其实就是一对公钥和私钥。**

- 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。

- **客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。**

#### 数据传输的机密性

**用非对称加密 对称加密的密钥，然后用对称加密密钥进行之后的加密通信**

对称加密：对称密码体制中只有私钥。所以得让对方知道密钥，所以要保证密钥的安全。

非对称加密：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有公钥和私钥，**公钥加密，私钥解密；私钥做数字签名，公钥验证。**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端，其中包含自己支持的**非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES))**，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。**客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。**

#### HTTPS 的SSL握手详细过程

![img](https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（与图上的数字不是一一对应的）

① **客户端**的浏览器向服务器发送请求，并传送客户端 **SSL 协议的版本号，加密算法的种类，产生的随机数**，以及其他服务器和客户端之间通讯所需要的各种信息。

② **服务器**向客户端传送**证书、 SSL 协议的版本号，加密算法的种类，随机数**以及其他相关信息。

③ **客户端**利用服务器传过来的信息**验证服务器的合法性**（由客户端的 TLS 来完成的），合法性检验包括：**证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 "发行者的数字签名"，服务器证书上的域名是否和服务器的实际域名相匹配**。如果合法性验证没有通过，通讯将断开。

④ **客户端**随机产生一个用于通讯的**对称加密密钥**，**用服务器的公钥对其加密（②中服务器证书中获得这个非对称加密密钥）**，然后将加密信息传给服务器，**这是为了让服务端得到这个密钥，之后的通信可以通过这个对称加密密钥来进行加密。**如果服务器要求客户的身份认证（在握手过程中为可选）：

- 客户端建立一个随机数然后对其进行数据签名，将这个含有签名的随机数、客户自己的证书、加密过的对称加密密钥密钥一起传给服务器。

- 服务器检验客户端证书和签名随机数的合法性，合法性验证包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断。

⑤ **服务器用私钥解密得到对称加密密钥，之后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。**

⑥ 服务器和客户端用对称加密密钥来进行 SSL 协议的安全数据通讯的加解密通讯，在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

- 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。

- 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

⑦ **SSL 的握手部分结束**，SSL 安全通道的数据通讯开始，**客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。**

### 3. DNS 域名系统

1. DNS缓存，DNS域名解析过程，接收到DNS查询结果之后还做了什么

#### 域名系统

​    域名系统DNS(Domain Name System)是因特网使用的命名系统，人比较容易记忆的主机名字，但机器在处理IP数据报时是使用IP地址。DNS使大多数名字都在本地解析，仅有少量解析需要在因特网上通信，因此DNS系统的效率很高。域名到IP地址的解析过程的要点如下：当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并称为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。

  在1983年因特网开始采用**层次树状结构的命名方法**，并使用**分布式的域名系统DNS**。并采用客户服务器方式。任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。

​    从语法上讲，每一个域名都是有标号(label)序列组成，而各标号之间用点(小数点)隔开。

​    如下例子所示：

​    ![img](https://img-blog.csdn.net/20140506151600093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

​    这是中央电视台用于手法电子邮件的计算机的域名，它由三个标号组成，其中标号com是顶级域名，标号cctv是二级域名，标号mail是三级域名。

​    DNS规定，域名中的标号都有英文和数字组成，每一个标号不超过63个字符(为了记忆方便，一般不会超过12个字符)，**不区分大小写字母，标号中除连字符(-)外不能使用其他的标点符号**。级别最低的域名写在最左边，而级别最高的字符写在最右边。由多个标号组成的完整域名总共不超过255个字符。DNS既不规定一个域名需要包含多少个下级域名，也不规定每一级域名代表什么意思。各级域名由其上一级的域名管理机构管理，**而最高的顶级域名则由ICANN进行管理**。

​    域名只是逻辑概念，并不代表计算机所在的物理地点。据2006年12月统计，现在顶级域名TLD(Top Level Domain)已有265个，分为三大类：

​    (1)国家顶级域名nTLD：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)。

​    (2)通用顶级域名gTLD：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)。

​    (3)基础结构域名(infrastructure domain)：这种顶级域名只有一个，即**arpa，用于反向域名解析，因此称为反向域名。**

​               ![img](https://img-blog.csdn.net/20140506153156531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 域名服务器

 一个服务器所负责管辖(或有权限)的范围叫做区(zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机到域名IP地址的映射。**区是DNS服务器实际管辖的范围。区 <= 域。**

​    下图是区的不同划分方法的举例。假定abc公司有下属部门x和y，部门x下面有分三个分布们u,v,w，而y下面还有下属部门t。图a表示abc公司只设一个区abc.com。这是，区abc.com和域abc.com指的是同一个。但图b表示abc公司划分为两个区：abc.com和y.abc.com。这两个区都隶属于域abc.com，都各设置了相应的权限域名服务器。

​              ![img](https://img-blog.csdn.net/20140507121231406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

​    下图是以上图b中abc公司划分的两个区为例，给出了DNS域名服务器树状结构图。这种DNS域名服务器树状结构图可以更准确地反映出DNS的分布式结构。当某个DNS服务器不能进行域名到IP地址的转换时，它就会设法找因特网上别的域名服务器进行解析。

​    从下图可以看出，因特网上的DNS服务器也是按照层次安排的。每一个域名服务器只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以把域名服务器划分为下面四种不同的类型。

- 根域名服务器：最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助根域名服务器。所以根域名服务器是最重要的域名服务器。假定所有的根域名服务器都瘫痪了，那么整个DNS系统就无法工作。需要注意的是，在很多情况下，**根域名服务器并不直接把待查询的域名直接解析出IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。**

- 顶级域名服务器：负责管理在该顶级域名服务器注册的二级域名。

- 权限域名服务器：负责一个“区”的域名服务器。

- 本地域名服务器：本地服务器不属于下图的域名服务器的层次结构，但是它对域名系统非常重要。**当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。**

​            ![img](https://img-blog.csdn.net/20140507121935890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 域名的解析过程

主机向本地域名服务器的查询一般都是采用**递归查询**：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

本地域名服务器向根域名服务器的查询的**迭代查询**：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

​        ![img](https://img-blog.csdn.net/20140507124241312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlwaWFua29uZ2JhaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  这两种查询的差别：

**递归**：客户端只发一次请求，要求对方给出最终结果，**返回的结果只有两种:查询成功或查询失败**

**迭代**：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。,**返回的是最佳的查询点或者主机地址**

**授权回答**：向dns服务器查询一个域名，刚好这个域名是本服务器负责，返回的结果就是授权回答。

**客户端-本地dns服务端：这部分属于递归查询。**

**本地dns服务端-外网：这部分属于迭代查询。**

 下面举一个例子演示整个查询过程：

​    假定域名为m.xyz.com的主机想知道另一个主机y.abc.com的IP地址。下面是上图a的几个查询步骤：

​    1、主机m.abc.com先向**本地服务器**dns.xyz.com进行递归查询。

​    2、本地服务器采用迭代查询。它先向一个**根域名服务器**查询。

​    3、根域名服务器告诉本地服务器，下一次应查询的**顶级域名服务器**dns.com的IP地址。

​    4、本地域名服务器向顶级域名服务器dns.com进行查询。

​    5、顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的**权限服务器**dns.abc.com的IP地址。

​    6、本地域名服务器向权限域名服务器dns.abc.com进行查询。

​    7、权限域名服务器dns.abc.com告诉本地域名服务器，所查询的**主机的IP地址**。

​    8、本地域名服务器最后把查询结果告诉m.xyz.com。

​    整个查询过程共用到了8个UDP报文。

#### DNS 缓存

为了提高DNS查询效率，域名服务器中广泛使用了**DNS高速缓存**，存放最近查询过的域名以及从何处获得域名映射信息的记录。由于名字到地址的绑定并不经常改变，为保持告诉缓存中的内容正确，域名服务器应为每项内容设置计时器TTL。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。

一条域名的DNS记录会在本地有两种缓存：**浏览器缓存和操作系统OS缓存**。在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问DNS服务器(一般是ISP提供)，然后DNS服务器会递归式的查找域名记录，然后返回。DNS记录会有一个ttl值(time to live)，单位是秒，意思是这个记录最大有效期是多少。

**OS缓存会参考ttl值，但是不完全等于ttl值，**

**浏览器DNS缓存的时间跟ttl值无关，每种浏览器都使用一个固定值。**

### 4.Web 页面请求过程

- DNS解析：浏览器查找域名的IP地址（DNS查找过程：浏览器缓存，路由器缓存，DNS缓存）  DNS，获取域名对应的IP地址
- TCP连接
- HTTP连接：浏览器向web服务器发送一个HTTP请求（cookies会随着请求发送给服务器），服务器处理请求（请求、处理请求&它的参数、cookies、生成一个HTML相应）
- 服务器返回一个HTML响应
- 浏览器显示HTML

所用到的协议：

DNS，获取域名对应的IP地址

TCP：与服务器建立TCP连接

IP：建立TCP连接时发送的数据在网络层使用IP协议

OSPF：IP数据包在路由器之间转发路由器选择OSPF

ARP：路由器与服务器通信时，将IP地址转换为MAC地址

HTTP：TCP建立完成后用HTTP协议访问网页



[GET和POST是HTTP请求的两种基本方法，区别](https://blog.csdn.net/ever_siyan/article/details/87935455) 

- GET把参数包含在URL中，POST通过request body传递参数
- GET产生一个TCP数据包；POST产生两个TCP数据包。
- GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
- POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

1. **DHCP 配置主机信息**

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

- 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。

- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。

- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

2. **ARP 解析 MAC 地址**

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

3. **DNS 解析域名**

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

4. **HTTP 请求页面**

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。

- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

#### 5.IP地址分类清楚吗？子网是怎么划分的，什么是子网掩码？

1. **分类：IP 地址 ::= {< 网络号 >, < 主机号 >}**

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"/> </div><br>

   A类网络的IP地址范围为：1.0.0.1－126.255.255.254；  

   B类网络的IP地址范围为：128.1.0.1－191.255.255.254；  127.x.x.x用作本地软件**环回测试**

   C类网络的IP地址范围为：192.0.1.1－223.255.255.254  

2. **子网划分**

   通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。

   **IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}**

   要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。外部网络看不到子网的存在。

3. **无分类编址 CIDR**

   **IP 地址 ::= {< 网络前缀号 >, < 主机号 >}**

   CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

   CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。
   一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   **构成超网**  。

   在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用**最长前缀匹配**来确定应该匹配哪一个。

   

4. 代理服务器的工作原理是怎样的？代理和网关有什么区别？

3. 了解cookie和session吗，二者有什么区别？




## OS

###  [进程通信](https://github.com/Sophia-fez/SE-IOS-Notes/blob/master/%E8%AE%A1%E7%BD%91%20OS/%E8%AE%A1%E7%BD%91.md)

   **（这是啥要查一下）文件通信->数据库通信->单例模式通信->redis通信**

   - 进程同步：控制多个进程按一定顺序执行
   - 进程通信：进程间传输信息

   进程通信的五种方式：管道、FIFO、消息队列、信号量、共享存储、套接字

   - 管道：速度慢，容量有限，只有父子进程能通讯    

   - FIFO：任何进程间都能通讯，但速度慢    

   - 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

   - 信号量：不能传递复杂消息，只能用来同步    

   - 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

   消息队列对比管道FIFO的优点：

   - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
   - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
   - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 进程和线程

   **进程：资源分配的基本单位**，一个进程中可以有多个线程，它们共享进程资源，线程不拥有资源，线程可以访问隶属进程的资源

   **线程：独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换

   - 系统开销
     由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
   - 通信方面
     线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。
   - [为什么有进程还要线程](https://blog.csdn.net/N1314N/article/details/93711245)：减少程序在并发执行时所付出的时空开销，提高并发性

### 线程安全（这部分比较迷）

线程安全性问题出现的三个必要条件：

- 多线程环境下

- 多个线程共享同一个资源

- 对资源进行非原子性操作

解决线程安全的四种方式：

- synchronized锁（偏向锁，轻量级锁，重量级锁）

- volatile英[ˈvɒlətaɪl]锁，只能保证线程之间的可见性，但不能保证数据的原子性

- jdk1.5并发包中提供的Atomic原子类

- Lock锁

-  多实例、或者是多副本（ThreadLocal）：对应着思路1 2，ThreadLocal可以为每个线程的维护一个私有的本地变量，可参考[java线程副本–ThreadLocal](http://blog.csdn.net/jinggod/article/details/78268020)；

一般说来，确保线程安全的方法有这几个：**竞争与原子操作、同步与锁、可重入、过度优化**。

**竞争与原子操作**
多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作被操作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。

因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于比较简单的场合，在复杂的情况下就要选用其他的方法了。

**同步与锁**
为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。

同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。

二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，要使用多元信号量(简称信号量)。

**可重入**
一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。

**过度优化**
在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安全，因此，我们可能对代码进行过度的优化以确保线程安全。

我们可以使用volatile关键字试图阻止过度优化，它可以做两件事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写回；第二，阻止编译器调整操作volatile变量的指令顺序。

在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困难，通常的解决办法是调用CPU提供的一条常被称作barrier的指令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。



**锁，知道的锁和用法**，程序锁，乐观锁，悲观锁，单线程锁，共享锁，非共享锁还有什么锁

### 进程的几种状态

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>

- 就绪状态（ready）：等待被调度

- 运行状态（running）

- 阻塞状态（waiting）：等待资源
  

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

### 死锁

必要条件：

- **互斥：**每个资源要么已经分配给了一个进程，要么就是可用的。
- **占有和等待**：已经得到了某个资源的进程可以再请求新的资源。
- **不可抢占：**已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- **环路等待：**有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

处理方法：

- **鸵鸟策略：**忽略它，假装根本没发生问题。

- **死锁检测与死锁恢复：**利用抢占恢复、利用回滚恢复、通过杀死进程恢复

- **死锁预防：**

    - **破坏互斥条件**，例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

    - **破坏占有和等待条件**，一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

    - **破坏不可抢占条件**

    - **破坏环路等待**，给资源统一编号，进程只能按编号顺序来请求资源。

- **死锁避免：**在程序运行时避免发生死锁，银行家算法

### 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。**每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。**当程序引用到不在物理内存中的页时**（缺页中断）**，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，即一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

### 分页

进程中的块称为页，内存中的块称为页框，外存中的块就叫块。分页管理系统里块是相等的长度。

一个虚拟地址分成两个部分，一部分存储**页号**，一部分**页内偏移量**

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165120.png" alt="QQ截图20201026165120" style="zoom:75%;" />

页表：系统为每个进程建立一张页表，页表由页表项组成，每一个页表项分为**页号**和**物理内存中的块号**两部分，物理内存中的块号与页内偏移量共同组成物理地址

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165402.png" alt="QQ截图20201026165402" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165425.png" alt="QQ截图20201026165425" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165459.png" alt="QQ截图20201026165459" style="zoom:75%;" />

分页管理系统中地址空间是一维的，页表不能太大，否则内存利用率会降低

### 分段

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。**每个段的长度可以不同，并且可以动态增长。**段内地址空间要求连续，段间不要求连续。

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165530.png" alt="QQ截图20201026165530" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165737.png" alt="QQ截图20201026165737" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165741.png" alt="QQ截图20201026165741" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165639.png" alt="QQ截图20201026165639" style="zoom:75%;" />

###  段页式

**程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。**这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。系统为每个进程建立一张段表，每个分段都有一张页表。在一个进程中，段表只有一个，但页表可能有多个。

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165827.png" alt="QQ截图20201026165827" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165822.png" alt="QQ截图20201026165822" style="zoom:75%;" />

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201026165923.png" alt="QQ截图20201026165923" style="zoom:75%;" />

### 分页与分段的比较

- 对程序员的透明性：分页透明，分段需要程序员显式划分每个段。

- 地址空间的维度：分页是一维地址空间，分段是二维的。

- 大小是否可以改变：**页的大小不可变，段的大小可以动态改变。**

- 出现的原因：**分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。**

### 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生**缺页中断**从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和**缓存淘汰策略**类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

1. **最佳（OPT, Optimal replacement algorithm）**

   所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。**是一种理论上的算法**，因为无法知道一个页面多长时间不再被访问。

   举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

2. **最近最久未使用（LRU, Least Recently Used）**

   虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

   为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

   因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>

3. **最近未使用（NRU, Not Recently Used）**

   每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

    - R=0，M=0
    - R=0，M=1
    - R=1，M=0
    - R=1，M=1

    当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

    NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

4. **先进先出（FIFO, First In First Out）**

   选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面换出，导致缺页率升高。

5. **第二次机会算法**

   FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

   当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

6. **时钟Clock**

   第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

## 数据结构

### 红黑树

1. 特点：

- 每个节点非红即黑
- 根结点总是黑的
- 叶子节点总是黑的空节点（nil节点）
- 如果节点是红色，它的子节点必须是黑色，反之不一定
- 从根结点到叶结点或空节点的每条路径，必须包含相同数目的黑色节点

2. 应用：TreeMap、TreeSet、HashMap底层

### B树B+树

B树也就是B-树

1. B树特点
   - B-tree是一种多路搜索树（并不是二叉的），对于一棵M阶树：
   - 定义任意非叶子结点最多只有M个孩子；且M>2；
   - 根结点的孩子数为[2, M]，除非根结点为叶子节点；
   - 除根结点以外的非叶子结点的儿子数为[M/2, M]；
   - 非叶子结点的关键字个数=指向儿子的指针个数-1；
   - 每个非叶子结点存放至少M/2-1（取上整）和至多M-1个关键字；
   - 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
   - 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
   - 所有叶子结点位于同一层；

<img src="D:\github\SE-IOS-Notes\image\QQ截图20201027001506.png" alt="QQ截图20201027001506" style="zoom:75%;" />

2. B+树

   B+-tree是应文件系统所需而产生的一种B-tree的变形树。

   B树和B+树的对比，一棵m阶的B+树和m阶的B树的异同点在于：

   - 有n棵子树的结点中含有n-1 个关键字；
   - 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
   - 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

### 排序算法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181125190554882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1h1bkNpeQ==,size_16,color_FFFFFF,t_70)

#### 1. 插入排序
#### ①直接插入排序
【空间】O(1)
【时间】排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟 
 最好O(n)，元素已有序，每插入一个元素都只需比较一次而不用移动元素
 最坏O(n2)，初始为逆序，总比较次数达到最大∑i=2n i，总的移动次数达到最大∑i=2n （i+1）
 平均O(n2)，初始顺序随机，总的比较次数和移动次数均约为n2/4
【比较次数与初始状态】√
【移动次数与初始状态】√
【一趟排序一个关键字到达最终位置】×，如1,2,3,4,5,0在最后一趟排序前没有任何一个关键字到达最终位置
【稳定性】√ 每次插入元素总是从后向前比较再移动，不会出现相同元素相对位置变化
【适用性】基本有序，数据量不大；顺序存储、链式存储（大部分排序只适用于顺序存储） 

##### ②折半排序
【空间】O(1)
【时间】相比于直接插入排序，查找插入位置上花的时间大大减少
 最好O(nlog2n)，
 最坏O(n2)，
 平均O(n2)，
【比较次数与初始状态】×，仅取决于表中元素个数n（二叉排序树高）
【移动次数与初始状态】√
【一趟排序一个关键字到达最终位置】×
【稳定性】√
【适用性】关键字较多时

##### ③希尔排序（缩小增量排序）
将待排序表按选区的“增量”分割成若干个特殊的子表，进行直接插入排序，希尔排序每趟都会使整个序列变得更加基本有序，最后再来一趟直接插入排序效率更高
增量选取
①希尔：⌊n/2⌋，⌊n/4⌋……⌊n/2k⌋……2,1
②帕佩尔诺夫和斯塔舍维奇：2k+1，……65,33，17,9,5,3,1，其中k为大于1的整数，2k+1<n,增量序列末尾的1是额外添加的，此时时间复杂度为O（n1.5）
注：①增量序列最后一定是1	②增量序列中的值应尽量没有除1以外的公因子（素数）
【空间】O(1)
【时间】依赖于增量系列
 最坏O(n2)
 平均O(nlog2n)
 n在特定范围内，O（n1.3）
【比较次数与初始状态】
【移动次数与初始状态】
【一趟排序一个关键字到达最终位置】
【稳定性】×，相同关键字可能被划分到不同的子表可能会改变他们的相对次序
【适用性】仅适用于顺序存储

#### 2. 交换排序
##### ①冒泡排序
在一趟排序过程中没有发生关键字交换则冒泡排序结束
【空间】O(1)
【时间】
 最好O(n)，初始有序，比较n-1次，移动0次
 最坏O(n2)，初始逆序，需要n-1趟排序，第i趟比较n-i次，每次需要移动元素3次交换元素位置，共比较次数∑i=1n-1 (n-i）=n(n-1)/2，移动次数∑i=1n-1  3(n-i）=3n(n-1)/2
 平均O(n2)
【比较次数与初始状态】√
【移动次数与初始状态】√
【一趟排序一个关键字到达最终位置】√
【稳定性】√
【适用性】

##### ②快速排序
划分思想，一趟后划分为左右两部分
【空间】递归需要栈，最好⌈log2(n+1) ⌉次即O(log2n)，最坏n-1次即O(n)
【时间】与划分是否对称有关，后者又与具体划分算法有关
 最好O(nlog2n)，平衡划分
 最坏O(n2)，初始序列基本有序或逆序，两个区域分别有n-1和0个元素，最大程度上的不对称发生在每一层递归上
 平均O(nlog2n)，是同级别里最好的
【比较次数与初始状态】√
【移动次数与初始状态】√
【一趟排序一个关键字到达最终位置】√
【稳定性】×
【适用性】初始序列越无序越高效，可根据第i趟是否有i个元素在最终位置，再比较其是否将序列划分为为左右两部分判断是否是快排

#### 3. 选择排序
##### ①简单选择排序
【空间】O(1)
【时间】移动次数很少，不会超过3(n-1)，有序时最好0次；比较次数与初始序列无关，始终是n(n-1)/2次，时间复杂度始终为O(n2)
【比较次数与初始状态】× O(n2)
【移动次数与初始状态】√ O(nn2)
【一趟排序一个关键字到达最终位置】√
【稳定性】× 第i趟找到最小元素后和第i个元素交换，可能导致相对位置发生变化，顺序表交换会导致不稳定，链表插入版不会导致不稳定，若无特别说明则是顺序表
【适用性】

##### ②堆排序
小根堆满足L(i)<=L(2i) && L(i)<=L(2i+1)，大根堆满足L(i)>=L(2i) && L(i)>=L(2i+1)
建立大根堆，输出堆顶（或者放到最后加入有序序列），将堆底元素送入堆顶，重新调整，重复以上过程直到堆中只剩一个元素
插入结点，按照完全二叉树插入在最底层最右边然后调整；删除结点，与最底层最右边结点交换再删除叶结点
筛选（调整），从无序序列所确定的完全二叉树第一个非叶结点，从右至左，从上至下依次调整。将结点p与其孩子值比较，若孩子大，与最大的孩子交换，p来到下一层重复以上操作直到孩子值都小于p
【空间】O(1)
【时间】O(nlog2n)，建堆O(n)， 只有n-1次向下调整，每次调整时间复杂度与树高有关为O(log2n)（也是插入一个、删除一个元素的复杂度）
【比较次数与初始状态】
【移动次数与初始状态】
【一趟排序一个关键字到达最终位置】√
【稳定性】× 进行筛选时有可能把后面相同关键字元素调整到前面
【适用性】在所有时间复杂度O(nlog2n)中空间复杂度最小，适合关键字较多的情况，如10000个关键字中选出10个最小
【题】小根堆，最大关键字一定存储在对应完全二叉树的叶子结点中，最后一个非叶子结点存储在⌊n/2⌋，所以最大关键字在⌊n/2⌋ +1~n之间

#### 4. 二路归并排序
K路归并n个元素，趟数m= ⌈logkn  ⌉
【空间】O(n)
【时间】O(nlog2n)，每一趟O(n)，共⌈log2n ⌉趟
【比较次数与初始状态】
【移动次数与初始状态】
【一趟排序一个关键字到达最终位置】×
【稳定性】√
【适用性】

#### 5.基数排序
借助“分配”和“收集”对单逻辑关键字操作，n个关键字，d为关键字位数，r为关键字基的个数，如930等三位数排序，d=3（3位），r=10（0~9）
【空间】O(r)
【时间】一趟分配O(n)，一趟收集O(r)，一共需要d趟分配和收集，时间复杂度O(d(n+r))，与初始状态无关
【比较次数与初始状态】
【移动次数与初始状态】
【一趟排序一个关键字到达最终位置】×
【稳定性】√
【适用性】关键字很多，但构成关键字的元素取值范围很小（r很小）。如果关键字取值范围也很大，如26个字母并且序列中大多数关键字关键字都不同，可以考虑使用“最高为优先”，根据最高位排成若干子序列，再对子序列进行直接插入排序

## C++/JAVA语言基础

1. 面向对象（封装，继承和多态）

2. hashmap的底层实现（红黑树）

3. [java实现线程同步的七种方法](https://www.cnblogs.com/cxxjohnson/p/8536257.html)

   同步方法
   同步代码块
   使用重入锁实现线程同步（ReentrantLock）
   使用特殊域变量(volatile)实现同步(每次重新计算，安全但并非一致)
   使用局部变量实现线程同步（ThreadLocal）以空间换时间
   使用原子变量实现线程同步(AtomicInteger(乐观锁))
   使用阻塞队列实现线程同步(BlockingQueue （常用）add(),offer(),put()

4. [C++ static关键字](https://www.cnblogs.com/__tudou__/p/11598140.html)

   static关键字主要起隐藏作用，static关键字在C\C++中都可以修饰内置类型变量、函数：

   面向过程设计中的static：静态全局变量、静态局部变量、静态函数
   面向对象的static关键字（类中的static关键字）：静态数据成员、静态成员函数

5. [指针和引用的区别](https://blog.csdn.net/l477918269/article/details/90233908)

   引用是别名，指针是地址。指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。

6. 面向对象六大原则

7. [堆栈](https://blog.csdn.net/yingms/article/details/53188974) 堆和栈的区别，他们都存什么内容，栈会溢出吗？什么情况下会溢出（待查）

   堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。

8. C++程序底层编译到运行的过程，代码到可执行文件的过程：预处理 编译 汇编 链接

9. 虚函数（待查）

10. python和C++的区别（待查）


## IOS

### MVC

MVC一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View

**Model（模型）**：处理数据逻辑的部分。通常Model对象负责在数据库中存取数据。

**View（视图）**：处理数据显示的部分。通常视图是依据模型数据创建的。

**Controller（控制器）**：处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

iOS中多数数据源视图控件（View）都有一个dataSource属性用于和控制器（Controller）交互，而数据来源一般会以数据模型（Model）的形式进行定义，View不直接和模型交互，而是通过Controller间接读取数据。

delegate 代理模式（设计模式的一种），用来处理事件监听、参数传递功能。

![img](https://bkimg.cdn.bcebos.com/pic/ac6eddc451da81cb26660e7e5066d01608243184?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

<img src="https://upload-images.jianshu.io/upload_images/7770244-f4fc955f1488299a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1127/format/webp" alt="img" style="zoom:50%;" />

### MVVM

MVVM把View和Contrller都放在了View层（相当于把Controller一部分逻辑抽离了出来），Model层依然是服务端返回的数据模型。而**ViewModel充当了一个UI适配器的角色**，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从**Controller抽离出来的与UI有关的逻辑都放在了ViewModel中**，这样就减轻了Controller的负担。

MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。

### UITableView、UITableViewCell

UITableView中每行数据都是一个UITableViewCell，UITableViewCell的内部有一个UIView控件（contentView，作为其他元素的父控件）、两个UILable控件（textLabel、detailTextLabel）、一个UIImage控件（imageView），分别用于容器、显示内容、详情和图片

UITableView对于数据源控件除了代理还有一个数据源属性，通过它和外界进行数据交互。 对于UITableView设置完dataSource后需要实现

![img](http://www.cocoachina.com/cms/uploads/allimg/140922/4196_140922110101_1.png)

![img](http://www.cocoachina.com/cms/uploads/allimg/140922/4196_140922110109_1.png)

支持**自定义UITableViewCell**，cell的复用，其中红色为可视区域，蓝色为屏幕外区域

<img src="https://upload-images.jianshu.io/upload_images/1322498-28c8d3a2b8b8f00f.png?imageMogr2/auto-orient/strip|imageView2/2/w/290/format/webp" alt="img" style="zoom: 75%;" /><img src="https://upload-images.jianshu.io/upload_images/1322498-e02c571c469a729d.png?imageMogr2/auto-orient/strip|imageView2/2/w/325/format/webp" alt="img" style="zoom:75%;" /><img src="https://upload-images.jianshu.io/upload_images/1322498-05fb712b0dfa16ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/326/format/webp" alt="img" style="zoom:75%;" />

- 对于在 MVC 的定义中，view 层是不引用 model 层，view 和 model 是不相往来的
- 一般开发中，在自定义 view 中增加一个 model 的属性，外接直接传个 model 来，在 view 中 model 的 set 方法里对 view 的控件赋值的代码，例如在自定义 UITableViewCell 时用的很多，此时 view 是直接引用了 model
- **基于封装的思想，需要尽可能的复用代码，复用view，所以需要进行解耦，不依赖于某个特殊的 model。**另外，如果对于很特殊的 view，整个项目中没有什么重用的，可以按之前情况处理

### 自定义UIButton，UIEdgeInsets属性

`UIButton`的另一个重要的属性就是`UIEdgeInsets`，称之为偏移量，分别有`contentEdgeInsets`、`imageEdgeInsets`、`titleEdgeInsets`三个相关属性。
 默认情况下：

- `contentEdgeInsets`的`top`、`left`、`bottom`、`right`都是相对于`button`本身，控制着`image`和`title`整体的偏移量；
- `imageEdgeInsets`的`top`、`left`、`bottom`相对于`button`，`right`相对于`title`，控制着`image`的相对偏移量；
- `titleEdgeInsets`的`top`、`bottom`、`right`相对于`button`，`left`相对于`image`，控制着`title`的相对偏移量；

### 堆和栈

[多线程中栈与堆是公有的还是私有的](https://www.jianshu.com/p/224a308a6347)

在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。

[地址从低到高：代码区、常量区、全局区（数据段）、堆空间、栈空间、动态库](https://blog.csdn.net/hairetz/article/details/4141043)

- 代码区：存放函数体的二进制代码
- 常量区：常量字符串就是放在这里的。程序结束后由系统释放 
- 全局区（静态区）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放。 

- 堆空间：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。与数据结构中的堆是两回事，分配方式倒是类似于链表

- 栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值，其操作方式类似于数据结构中的栈。

**堆和栈的区别：**

**一、堆栈空间分配区别：**

1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

**二、堆栈缓存方式区别：**

1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

2、堆是存放在二级缓存，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化

栈：是内存中存储值类型的，大小为2M，超出则会报错，内存溢出

**三、堆栈数据结构区别：**

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。

### [循环引用](https://www.jianshu.com/p/e3302eac8536)

iOS内存中的分区有：堆、栈、静态区。其中，栈和静态区是操作系统自己管理回收，不会造成循环引用。在堆中的相互引用无法回收，有可能造成循环引用。

循环引用的实质：多个对象相互之间有强引用，不能施放让系统回收。

解决循环引用一般是将 strong 引用改为 weak 引用。

1. **父类与子类**

如：在使用UITableView 的时候，将 UITableView 给 Cell 使用，cell 中的 strong 引用会造成循环引用。

解决：strong 改为 weak

2. **block**

block在copy时都会对block内部用到的对象进行强引用的。self将block作为自己的属性变量，而在block的方法体里面又引用了 self 本身，此时就很简单的形成了一个循环引用。

在 ARC 中，在被拷贝的 block 中无论是直接引用 self 还是通过引用 self 的成员变量间接引用 self，该 block 都会 retain self。

3. **Delegate**

delegate 属性的声明如下：@property (nonatomic, weak) id <TestDelegate> delegate;
如果将 weak 改为 strong，则会造成循环引用

4. **NSTimer**

NSTimer 的 target 对传入的参数都是强引用（即使是 weak 对象）

计时器保留其目标对象，反复执行任务导致的循环，确实要注意，另外在dealloc的时候，不要忘了调用计时器中的 invalidate方法。

<img src="https://upload-images.jianshu.io/upload_images/6618656-d08f3092a97ab9e3?imageMogr2/auto-orient/strip|imageView2/2/w/1110/format/webp" alt="img" style="zoom:50%;" />


### 常见汇编指令

![clipboard](D:\github\SE-IOS-Notes\image\clipboard.png)

### 设计模式

![img](https://upload-images.jianshu.io/upload_images/301129-2c27c621a8eb8d05.png?imageMogr2/auto-orient/strip|imageView2/2/w/912/format/webp)

## [智力题](https://blog.csdn.net/qq_40058686/article/details/104664136)

1. **100层楼，给你两个鸡蛋，怎么确定在哪一层是摔坏的，而在那一层之下不会碎？**

- **第 1 次在第 x 层尝试**，如果碎了，就从1遍历到 x-1 ；如果没碎，那么**第 2 次在第 x +（x-1）层尝试**。因为假设通过 x 步得到答案，在第 x 层尝试了一次，还剩下 x-1 次尝试机会，所以选择第 x +（x-1）层尝试，第 x 层到 第 x +（x-1）层之间刚好可以尝试 x - 2次，这样一共最多尝试x次。
- **第 2 次在第  x +（x-1）层尝试**，如果碎了，遍历 x+1 到 x +（x-1）-1的所有楼层；如果没碎，尝试在第 x +（x-1）+（x-2）层摔
- ……

- 一直操作，直到碎掉，所以楼层公式为x(x+1)/2

 

2. 岛上有群人，各自戴着**红帽子或者白帽子**，但都不知道自己帽子颜色，只有知道自己帽子颜色，第二天才能出岛，这时候有个人进来说了句”**你们之中至少有一个人戴了顶红帽子**”，问岛上的人最后的离开情况

   **如果有 n 个红帽子，那么第 n+1 天后红帽子的都能走掉，n+2 天后白帽子的都能走掉**

   - 假如只有一个红帽子，那么戴红帽子的第二天就会走。一个人他看到其他所有人带的都是白帽子，所以知道了自己是红帽子，所以红帽子第二天走了，剩下的白帽子第三天走了。
   - 假如是两个红帽子，这两个红帽子都不能确定自己的颜色，所以第二天都不会走，但是假如这两个人都发现第二天对方没走，那么就能知道自己戴的是红帽子，所以第三天两个红帽子都走了，第四天白帽子全走，以此类推。

 

3. 总共100个球，两个人分别拿，至少拿1个最多拿5个，你先拿怎么保证总能拿到第100个？

   假如最后我拿了之后剩余的是1到5个，那么最后一个肯定是对方拿到了，而我假如最后拿了剩6个，那么无论对方怎么拿我都能保证第100个是我拿的，接着想假如我拿了之后剩12个，那么无论对方怎么拿我都能够将个数减到6个，所以只要我先拿然后每次保证剩余个数是6的倍数就行了

 

4. 小明一家五口人喜欢探险，一天黑夜，他们被困在一座悬崖之上，好在他们发现了一座独木桥，但是他们唯一能照明的手电只能亮二十九秒了。小明过桥需要 3 秒钟，小明的爸爸只要1 秒钟，妈妈需要 6 秒钟，爷爷需要 8 秒钟，而奶奶则需要 12 秒钟，他们必须在这二十九秒内全部过河，但独木桥最多一次能承重 2 个人，同时必须保证在独木桥上的人有手电照明，应该如何安排过桥顺序呢？
   - 爸爸拿手电和小明过去，3s
   - 爸爸拿手电筒回来：1s
   - 手电筒给爷爷奶奶，12s
   - 手电筒给小明，小明回来：3s
   - 手电筒给爸爸妈妈：6s
   - 爸爸回来：1s
   - 爸爸和小明过去：3s
   - 总共29s

 

5. 一个ip和海量ip黑名单，怎么判断ip是否在黑名单中？

   使用布隆过滤器。它有一个位数组和k个哈希函数，我们先使用k个哈希函数对这个ip进行k次计算，就能够得到k个哈希值了，然后根据得到的哈希值去判断位数组中对应下标的值是否为1，如果都为1，那么就在布隆过滤器中，只要有一个不为1，那么就不在。但是布隆过滤器可能存在误判（也就是说如果某个元素存在，那么可能是误判，但是某个元素不在，那么就一定不在）。这个时候可以通过设置白名单来结果误判的问题

   不适用位图的原因是因为位图法所占空间随着集合内最大元素的增大而增大，假如查找的元素数量少但是值特别大，那么就会特别浪费空间

 

6. 海量数据找中位数？

   首先对海量数据进行分份，然后遍历每一份中的所有数据，每个数据用位运算去除最高的8位，然后根据最高的8位的值确定放入哪个桶里，再把每个桶写入一个磁盘文件中，并且统计每个桶内数据的数量，计算中位数是在哪个桶中，再把该桶中的数据读到内存中，以内存中整数的次高8bit又进行一次桶排序，和第一步相同的操作，一直这样知道字节是（0-7bit），这个时候再在内存中进行一次快排就行了